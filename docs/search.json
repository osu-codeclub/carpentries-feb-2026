[
  {
    "objectID": "0_setup.html",
    "href": "0_setup.html",
    "title": "Install and set up R and RStudio",
    "section": "",
    "text": "Before the workshop starts, you’ll need to install R (the programming language), RStudio (the editor/IDE we’ll use to interact with R), and if you can, two R packages. The instructions to do so follow below."
  },
  {
    "objectID": "0_setup.html#install-r-and-rstudio",
    "href": "0_setup.html#install-r-and-rstudio",
    "title": "Install and set up R and RStudio",
    "section": "1 Install R and RStudio",
    "text": "1 Install R and RStudio\n\n1.1 Alternative 1: If you have an OSU-managed computer\nIf you are using an OSU computer, you may not have the “administrative privileges” that are needed to install software on your computer the regular way.\nHowever, you should in that case have an OSU application on your computer that allows you to install a selection of approved software, including R and RStudio. On Windows, this app should be called “Software Center”, and on Mac, “Ohio State Application Self Service”.\nFind that application and inside it, install R and RStudio using this app.\n\n\n1.2 Alternative 2: If you have a personal computer\nBelow, there’s a separate tab with installation instructions for each operating system:\n\nWindowsMacOSLinux\n\n\nInstallation on Windows:\n\nInstall R: download and run this .exe file from CRAN.\nInstall RStudio: Click the download button below “Install RStudio” on this page.\n\n\n\n\n\n\n\nWarningInstall as administrator if possible\n\n\n\nNote that if you have separate user and admin accounts, you should run the installers as administrator (right-click on the .exe file and select “Run as administrator” instead of double-clicking). Otherwise problems may occur later, for example when installing R packages.\n\n\nThe video below walks you through this process:\n\n\n\nInstallation on MacOS:\n\nInstall R: download and run this .pkg file from CRAN.\nInstall RStudio: Click the download button below “Install RStudio” on this page.\n\nThe video below walks you through this process:\n\n\n\nInstallation on Linux:\n\nInstall R: Instructions for R installation on various Linux platforms (Debian, Fedora, Redhat, and Ubuntu) can be found at https://cran.r-project.org/bin/linux/.\nInstall RStudio: Click the download button below “Install RStudio” on this page."
  },
  {
    "objectID": "0_setup.html#install-two-r-packages",
    "href": "0_setup.html#install-two-r-packages",
    "title": "Install and set up R and RStudio",
    "section": "2 Install two R packages",
    "text": "2 Install two R packages\nIf you are comfortable doing so, please install two so-called R packages (basically, add-ons to the functionality of the language) that we will be using during the workshop, which you do as follows:\n\nOpen RStudio on your computer\nIn RStudio, find the R “Console”: this is the primary tab in the (bottom) left panel\nType or paste the following commands in the R Console, pressing Enter (Return) after each:\n\ninstall.packages(\"gapminder\")\ninstall.packages(\"tidyverse\")\n\nYou should see a bunch of text stream by in the Console while these packages are being installed. When it’s done, test that the packages were successfully installed by loading them:\n\nlibrary(gapminder)\nlibrary(tidyverse)\n\n\nThe first command should produce no output, but the second should, similar to what’s shown in this screenshot:\n\n\n\n\n\nIf you got an error instead when loading one or both packages, please contact one of the instructors."
  },
  {
    "objectID": "0_setup.html#using-posit-cloud",
    "href": "0_setup.html#using-posit-cloud",
    "title": "Install and set up R and RStudio",
    "section": "3 Using Posit Cloud",
    "text": "3 Using Posit Cloud\nHaving trouble getting R/RStudio to work? You can try using RStudio through Posit Cloud.\n\nGo to https://posit.cloud and click “get started”:\n\n\n\n\n\n\n\nSelect “Learn more” under “Cloud Free”:\n\n\n\n\n\n\n\nSign up for Cloud Free by creating an account, or signing in with Google, GitHub, or Clever.\nCreate a New Project &gt; New RStudio Project:\n\n\n\n\n\n\n\n\nNow you can use R through RStudio on Posit Cloud!"
  },
  {
    "objectID": "3_dplyr.html#introduction",
    "href": "3_dplyr.html#introduction",
    "title": "Data wrangling with dplyr",
    "section": "1 Introduction",
    "text": "1 Introduction\n\n1.1 The dplyr package and the tidyverse\nThe dplyr package provides very useful functions for manipulating data in data frames (“data wrangling”). This type of data processing is often essential before you can move on to say, data visualization (next session of this workshop) or statistical data analysis.\nIn this session, we’ll cover the most commonly used dplyr functions:\n\nselect() to pick columns (variables)\nfilter() to pick rows (observations)\nrename() to change column names\narrange() to change the order of rows (i.e., to sort a data frame)\nmutate() to modify values in columns and create new columns\nsummarize() to compute across-row summaries\n\nAll these functions take a data frame as the input, and output a new, modified data frame.\ndplyr belongs to a family of R packages designed for “dataframe-centric” data science called the “tidyverse”. Dataframe-centric refers to doing most if not all data analysis while keeping the data in R’s data frame data structure. Another tidyverse package we’ll cover in today’s workshop is ggplot2 for making plots.\n\n\n1.2 Setting up\nUse a new script for this session – much like in the previous session:\n\nOpen a new R script (Click the + symbol in toolbar at the top, then click R Script)1.\nSave the script straight away as data-wrangling.R – you can save it anywhere you like, though it is probably best to save it in a folder specifically for this workshop.\nIf you want the section headers as comments in your script, like in the script I am showing you in the live session, then copy-and-paste the following into your script:\n\n\n\nSection headers for your script (Click to expand)\n\n\n# 1 - Introduction ----------------------------------------------------\n# 1.3 - Loading the tidyverse\n\n# 1.4 - The gapminder dataset\n\n# 2 - select() to pick columns (variables) ----------------------------\n\n# 3 - rename() to change column names ---------------------------------\n\n# 4 - The pipe |&gt; -----------------------------------------------------\n\n# 5 - filter() to pick rows (observations) ----------------------------\n\n# Challenge 1\n# Use a \"pipeline\" like above to output a data frame with\n# columns `year`, `country`, and `lifeExp`, only for countries in Africa.\n# How many rows does your output data frame have?\n  \n# 6 - arrange() to sort data frames -----------------------------------\n\n# 7 - mutate() to modify columns and create new ones ------------------\n\n# Challenge 2\n# Use mutate() to create a new column called gdp_billion that has the\n# absolute GDP (i.e., not relative to population size) and does so in\n# units of billions (i.e., 2.3 would mean 2.3 billion).\n\n# 8 - summarize() to compute summary stats ----------------------------\n\n# Challenge 3\n# Calculate the average life expectancy per country.\n# Which has the longest average life expectancy and which has the\n# shortest average life expectancy?\n\n\n\n\n1.3 Loading the tidyverse\nAll core tidyverse packages can be installed and loaded with a single command. Since you should already have installed the tidyverse2, you only need to load it, which you do as follows:\n\nlibrary(tidyverse)\n\nWarning: package 'ggplot2' was built under R version 4.5.2\n\n\nWarning: package 'tidyr' was built under R version 4.5.2\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThe output tells you which packages have been loaded as part of the tidyverse. (For now, you don’t have to worry about the “Conflicts” section.)\n\n\n1.4 The gapminder dataset\nIn this session and the next one on data visualization, we will work with the gapminder dataset, which contains statistics such as population size for different countries across five-year intervals.\nThis dataset is available in a package of the same name, which you also should have already installed3. To load the package into your current R session:\n\n# (Unlike with the tidyverse, no output is expected when you load gapminder)\nlibrary(gapminder)\n\nTake a look at the gapminder data frame that is now available to you:\n\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nYou can also use the View() function to look at the data frame. This will open a new tab in your editor pane with a spreadsheet-like look and feel:\n\nView(gapminder)\n# (Should display the dataset in an editor pane tab)\n\nThe gapminder data frame is a so-called “tibble”, which is the tidyverse variant of a data frame. The main difference is the nicer default printing behavior of tibbles: e.g. the data types of columns are shown, and only a limited number of rows are printed.\nEach row of this data frame contains statistics for a single country in a specific year (across five-year intervals between 1952 and 2007), with the following columns:\n\ncountry (stored as a factor, an alternative to character that can be used for categorical data)\ncontinent (stored as a factor)\nyear (stored as an integer)\nlifeExp (stored as an integer): the life expectancy in years\npop (stored as an integer): the population size\ngdpPercap (stored as a double): the per-capita GDP"
  },
  {
    "objectID": "3_dplyr.html#select-to-pick-columns-variables",
    "href": "3_dplyr.html#select-to-pick-columns-variables",
    "title": "Data wrangling with dplyr",
    "section": "2 select() to pick columns (variables)",
    "text": "2 select() to pick columns (variables)\nThe first dplyr function you’ll learn about is select(), which subsets a data frame by including/excluding certain columns. By default, it only includes the columns you specify:\n\nselect(.data = gapminder, year, country, pop)\n\n# A tibble: 1,704 × 3\n    year country          pop\n   &lt;int&gt; &lt;fct&gt;          &lt;int&gt;\n 1  1952 Afghanistan  8425333\n 2  1957 Afghanistan  9240934\n 3  1962 Afghanistan 10267083\n 4  1967 Afghanistan 11537966\n 5  1972 Afghanistan 13079460\n 6  1977 Afghanistan 14880372\n 7  1982 Afghanistan 12881816\n 8  1987 Afghanistan 13867957\n 9  1992 Afghanistan 16317921\n10  1997 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nAbove, the first argument was the data frame, whereas the other arguments were the (unquoted!) names of columns to be included in the output data frame4.\nThe order of the columns in the output data frame is exactly as you list them in select(), and doesn’t need to be the same as in the input data frame. In other words, select() is also one way to reorder columns: in the example above, we made year appear before country.\nYou can also specify columns that should be excluded, by prefacing their name with a ! (or a -):\n\n# This will include all columns _except_ continent:\nselect(.data = gapminder, !continent)\n\n# A tibble: 1,704 × 5\n   country      year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\nThere are also ways to e.g. select ranges of columns that are beyond the scope of this short workshop. Check the select() help by typing ?select to learn more."
  },
  {
    "objectID": "3_dplyr.html#rename-to-change-column-names",
    "href": "3_dplyr.html#rename-to-change-column-names",
    "title": "Data wrangling with dplyr",
    "section": "3 rename() to change column names",
    "text": "3 rename() to change column names\nThe next dplyr function is one of the simplest: rename() to change column names.\nThe syntax to specify the new and old name within the function is new_name = old_name. For example, to rename the gdpPercap column:\n\nrename(.data = gapminder, gdp_per_capita = gdpPercap)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdp_per_capita\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;          &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333           779.\n 2 Afghanistan Asia       1957    30.3  9240934           821.\n 3 Afghanistan Asia       1962    32.0 10267083           853.\n 4 Afghanistan Asia       1967    34.0 11537966           836.\n 5 Afghanistan Asia       1972    36.1 13079460           740.\n 6 Afghanistan Asia       1977    38.4 14880372           786.\n 7 Afghanistan Asia       1982    39.9 12881816           978.\n 8 Afghanistan Asia       1987    40.8 13867957           852.\n 9 Afghanistan Asia       1992    41.7 16317921           649.\n10 Afghanistan Asia       1997    41.8 22227415           635.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "3_dplyr.html#the-pipe",
    "href": "3_dplyr.html#the-pipe",
    "title": "Data wrangling with dplyr",
    "section": "4 The pipe (|>)",
    "text": "4 The pipe (|&gt;)\nExamples so far applied a single dplyr function to a data frame, simply printing the output (a new data frame) to screen. But in practice, it’s common to use several consecutive dplyr functions to wrangle a dataframe into the format you want.\nFor example, you may want to first select() one or more columns, and then rename() a column. You could do that as follows:\n\ngapminder_sel &lt;- select(.data = gapminder, year, country, gdpPercap)\n\nrename(.data = gapminder_sel, gdp_per_capita = gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdp_per_capita\n   &lt;int&gt; &lt;fct&gt;                &lt;dbl&gt;\n 1  1952 Afghanistan           779.\n 2  1957 Afghanistan           821.\n 3  1962 Afghanistan           853.\n 4  1967 Afghanistan           836.\n 5  1972 Afghanistan           740.\n 6  1977 Afghanistan           786.\n 7  1982 Afghanistan           978.\n 8  1987 Afghanistan           852.\n 9  1992 Afghanistan           649.\n10  1997 Afghanistan           635.\n# ℹ 1,694 more rows\n\n\nAnd you could go on along these lines, successively creating new objects that you then use for the next step.\nBut there is a more elegent way of dong this, directly sending (“piping”) output from one function into the next function with the pipe operator |&gt; (a vertical bar | followed by a greater-than sign &gt;). Let’s start by seeing a reformulation of the code above with pipes:\n\ngapminder |&gt;\n  select(year, country, gdpPercap) |&gt;\n  rename(gdp_per_capita = gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdp_per_capita\n   &lt;int&gt; &lt;fct&gt;                &lt;dbl&gt;\n 1  1952 Afghanistan           779.\n 2  1957 Afghanistan           821.\n 3  1962 Afghanistan           853.\n 4  1967 Afghanistan           836.\n 5  1972 Afghanistan           740.\n 6  1977 Afghanistan           786.\n 7  1982 Afghanistan           978.\n 8  1987 Afghanistan           852.\n 9  1992 Afghanistan           649.\n10  1997 Afghanistan           635.\n# ℹ 1,694 more rows\n\n\nWhat happened here? We took the gapminder data frame, sent (“piped”) it into the select() function, whose output in turn was piped into the rename() function. You can think of the pipe as “then”: take gapminder, then select, then rename.\nWhen using the pipe, you no longer specify the input data frame with the .data argument, because the function now gets its input data via the pipe (specifically, the input goes to the function’s first argument by default).\n\n\n\n\n\n\nUsing pipes involves less typing and is especially more readable than using successive assignments5.\nFor code readability, it is good practice to always start a new line after a pipe |&gt;, and to keep the subsequent line(s) indented as RStudio will automatically do."
  },
  {
    "objectID": "3_dplyr.html#filter-to-pick-rows-observations",
    "href": "3_dplyr.html#filter-to-pick-rows-observations",
    "title": "Data wrangling with dplyr",
    "section": "5 filter() to pick rows (observations)",
    "text": "5 filter() to pick rows (observations)\n\n5.1 Introduction\nThe filter() function outputs only those rows that satisfy one or more conditions. It is similar to Filter functionality in Excel — except that those only change what you display, while filter() will completely exclude rows.\nBut if that sounds scary, recall that dplyr functions always output a new data frame. Therefore, with any dplyr function, you’ll only modify existing data when you assign the output back to the input object, like in this example with the select() function:\n\n# [Don't run this - hypothetical example]\n# After running this, any columns in the 'cats' dataframe other than 'name'\n# and 'coat' would be removed from it:\ncats &lt;- cats |&gt; select(name, coat)\n\n\n\n5.2 Filter based on one condition\nThis first filter() example outputs only rows for which the life expectancy exceeds 80 years (remember, each row represents a country in a given year):\n\ngapminder |&gt;\n  filter(lifeExp &gt; 80)\n\n# A tibble: 21 × 6\n   country          continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Australia        Oceania    2002    80.4 19546792    30688.\n 2 Australia        Oceania    2007    81.2 20434176    34435.\n 3 Canada           Americas   2007    80.7 33390141    36319.\n 4 France           Europe     2007    80.7 61083916    30470.\n 5 Hong Kong, China Asia       2002    81.5  6762476    30209.\n 6 Hong Kong, China Asia       2007    82.2  6980412    39725.\n 7 Iceland          Europe     2002    80.5   288030    31163.\n 8 Iceland          Europe     2007    81.8   301931    36181.\n 9 Israel           Asia       2007    80.7  6426679    25523.\n10 Italy            Europe     2002    80.2 57926999    27968.\n# ℹ 11 more rows\n\n\n\n\n How many rows were output? (Click to see the answer)\n\n\n21 rows were output, as shown in the first line above: 21 x 6 (rows x columns)\n\n\nAs the example above demonstrated, filter() outputs rows that satisfy the condition(s) you specify. These conditions don’t have to be based on numeric comparisons:\n\n# Only keep rows where the value in the 'continent' column is 'Europe':\ngapminder |&gt;\n  filter(continent == \"Europe\")\n\n# A tibble: 360 × 6\n   country continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Albania Europe     1952    55.2 1282697     1601.\n 2 Albania Europe     1957    59.3 1476505     1942.\n 3 Albania Europe     1962    64.8 1728137     2313.\n 4 Albania Europe     1967    66.2 1984060     2760.\n 5 Albania Europe     1972    67.7 2263554     3313.\n 6 Albania Europe     1977    68.9 2509048     3533.\n 7 Albania Europe     1982    70.4 2780097     3631.\n 8 Albania Europe     1987    72   3075321     3739.\n 9 Albania Europe     1992    71.6 3326498     2497.\n10 Albania Europe     1997    73.0 3428038     3193.\n# ℹ 350 more rows\n\n\n\n\n\n\n\n\nWarningRemember to use two equals signs == to test for equality!\n\n\n\n\n\n\n\n\n5.3 Filter based on multiple conditions\nIt’s also possible to filter based on multiple conditions. For example, you may want to see which countries in Asia had a life expectancy greater than 80 years in 2007:\n\ngapminder |&gt;\n  filter(continent == \"Asia\", year == 2007, lifeExp &gt; 80)\n\n# A tibble: 3 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Hong Kong, China Asia       2007    82.2   6980412    39725.\n2 Israel           Asia       2007    80.7   6426679    25523.\n3 Japan            Asia       2007    82.6 127467972    31656.\n\n\nLike above, by default, multiple conditions are combined using a Boolean AND. In other words, in a given row, each condition must be met to output the row.\nIf you want to combine conditions using a Boolean OR, where only one of the conditions needs to be met, use a | between the conditions:\n\n# Keep rows with a high life expectancy and/or a high GDP:\ngapminder |&gt;\n  filter(lifeExp &gt; 80 | gdpPercap &gt; 10000)\n\n# A tibble: 392 × 6\n   country   continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Argentina Americas   1977    68.5 26983828    10079.\n 2 Argentina Americas   1997    73.3 36203463    10967.\n 3 Argentina Americas   2007    75.3 40301927    12779.\n 4 Australia Oceania    1952    69.1  8691212    10040.\n 5 Australia Oceania    1957    70.3  9712569    10950.\n 6 Australia Oceania    1962    70.9 10794968    12217.\n 7 Australia Oceania    1967    71.1 11872264    14526.\n 8 Australia Oceania    1972    71.9 13177000    16789.\n 9 Australia Oceania    1977    73.5 14074100    18334.\n10 Australia Oceania    1982    74.7 15184200    19477.\n# ℹ 382 more rows\n\n\n\n\n5.4 Pipeline practice\nFinally, let’s practice another time with “pipelines” that use multiple dplyr functions: filter rows, then select columns, and finally rename one of the remaining columns:\n\ngapminder |&gt;\n  filter(continent == \"Americas\") |&gt;\n  select(year, country, gdpPercap) |&gt;\n  rename(gdp_per_capita = gdpPercap)\n\n# A tibble: 300 × 3\n    year country   gdp_per_capita\n   &lt;int&gt; &lt;fct&gt;              &lt;dbl&gt;\n 1  1952 Argentina          5911.\n 2  1957 Argentina          6857.\n 3  1962 Argentina          7133.\n 4  1967 Argentina          8053.\n 5  1972 Argentina          9443.\n 6  1977 Argentina         10079.\n 7  1982 Argentina          8998.\n 8  1987 Argentina          9140.\n 9  1992 Argentina          9308.\n10  1997 Argentina         10967.\n# ℹ 290 more rows\n\n\n\n Challenge 1\nUse a “pipeline” like above to output a data frame with columns year, country, and lifeExp, only for countries in Africa. How many rows does your output data frame have?\n\n\nClick for the solution\n\n\ngapminder |&gt;\n  filter(continent == \"Africa\") |&gt;\n  select(year, country, lifeExp)\n\n# A tibble: 624 × 3\n    year country lifeExp\n   &lt;int&gt; &lt;fct&gt;     &lt;dbl&gt;\n 1  1952 Algeria    43.1\n 2  1957 Algeria    45.7\n 3  1962 Algeria    48.3\n 4  1967 Algeria    51.4\n 5  1972 Algeria    54.5\n 6  1977 Algeria    58.0\n 7  1982 Algeria    61.4\n 8  1987 Algeria    65.8\n 9  1992 Algeria    67.7\n10  1997 Algeria    69.2\n# ℹ 614 more rows\n\n\nThe output data frame has 624 rows."
  },
  {
    "objectID": "3_dplyr.html#arrange-to-sort-data-frames",
    "href": "3_dplyr.html#arrange-to-sort-data-frames",
    "title": "Data wrangling with dplyr",
    "section": "6 arrange() to sort data frames",
    "text": "6 arrange() to sort data frames\nThe arrange() function is like sorting functionality in Excel: it changes the order of rows based on the values in one or more columns6.\ngapminder is currently first sorted alphabetically by country, and next by year. But you may, for example, want to sort by population size instead:\n\ngapminder |&gt;\n  arrange(pop)\n\n# A tibble: 1,704 × 6\n   country               continent  year lifeExp   pop gdpPercap\n   &lt;fct&gt;                 &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt;\n 1 Sao Tome and Principe Africa     1952    46.5 60011      880.\n 2 Sao Tome and Principe Africa     1957    48.9 61325      861.\n 3 Djibouti              Africa     1952    34.8 63149     2670.\n 4 Sao Tome and Principe Africa     1962    51.9 65345     1072.\n 5 Sao Tome and Principe Africa     1967    54.4 70787     1385.\n 6 Djibouti              Africa     1957    37.3 71851     2865.\n 7 Sao Tome and Principe Africa     1972    56.5 76595     1533.\n 8 Sao Tome and Principe Africa     1977    58.6 86796     1738.\n 9 Djibouti              Africa     1962    39.7 89898     3021.\n10 Sao Tome and Principe Africa     1982    60.4 98593     1890.\n# ℹ 1,694 more rows\n\n\nSorting can help you find observations with the smallest or largest values for a certain column: above, we see that the smallest population size in the dataset is Sao Tome and Principe in 1952.\nDefault sorting is from small to large, as seen above . To sort in reverse order, use the desc() (descending) helper function:\n\ngapminder |&gt;\n  arrange(desc(pop))\n\n# A tibble: 1,704 × 6\n   country continent  year lifeExp        pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n 1 China   Asia       2007    73.0 1318683096     4959.\n 2 China   Asia       2002    72.0 1280400000     3119.\n 3 China   Asia       1997    70.4 1230075000     2289.\n 4 China   Asia       1992    68.7 1164970000     1656.\n 5 India   Asia       2007    64.7 1110396331     2452.\n 6 China   Asia       1987    67.3 1084035000     1379.\n 7 India   Asia       2002    62.9 1034172547     1747.\n 8 China   Asia       1982    65.5 1000281000      962.\n 9 India   Asia       1997    61.8  959000000     1459.\n10 China   Asia       1977    64.0  943455000      741.\n# ℹ 1,694 more rows\n\n\nFinally, you may want to sort by multiple columns, where ties in the first column are broken by a second column (and so on). Do this by simply listing the columns in the appropriate order:\n\n# Sort first by continent, then by country:\ngapminder |&gt;\n  arrange(continent, country)\n\n# A tibble: 1,704 × 6\n   country continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Algeria Africa     1952    43.1  9279525     2449.\n 2 Algeria Africa     1957    45.7 10270856     3014.\n 3 Algeria Africa     1962    48.3 11000948     2551.\n 4 Algeria Africa     1967    51.4 12760499     3247.\n 5 Algeria Africa     1972    54.5 14760787     4183.\n 6 Algeria Africa     1977    58.0 17152804     4910.\n 7 Algeria Africa     1982    61.4 20033753     5745.\n 8 Algeria Africa     1987    65.8 23254956     5681.\n 9 Algeria Africa     1992    67.7 26298373     5023.\n10 Algeria Africa     1997    69.2 29072015     4797.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "3_dplyr.html#mutate-to-modify-columns-and-create-new-ones",
    "href": "3_dplyr.html#mutate-to-modify-columns-and-create-new-ones",
    "title": "Data wrangling with dplyr",
    "section": "7 mutate() to modify columns and create new ones",
    "text": "7 mutate() to modify columns and create new ones\nSo far, we’ve focused on functions that subset and reorganize data frames (and you’ve seen how to modify column names). But you haven’t seen how you can change the data or compute derived data.\nThis can be done with the mutate() function. For example, to create a new column that has population sizes in millions rather than in individuals:\n\n# Create a new column 'pop_million' by dividing 'pop' by a million:\ngapminder |&gt;\n  mutate(pop_million = pop / 10^6)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap pop_million\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.        8.43\n 2 Afghanistan Asia       1957    30.3  9240934      821.        9.24\n 3 Afghanistan Asia       1962    32.0 10267083      853.       10.3 \n 4 Afghanistan Asia       1967    34.0 11537966      836.       11.5 \n 5 Afghanistan Asia       1972    36.1 13079460      740.       13.1 \n 6 Afghanistan Asia       1977    38.4 14880372      786.       14.9 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.9 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       13.9 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       16.3 \n10 Afghanistan Asia       1997    41.8 22227415      635.       22.2 \n# ℹ 1,694 more rows\n\n\nTo modify an existing column rather than adding a new one, simply “assign back to the same name”:\n\n# Change the unit of the 'pop' column:\ngapminder |&gt;\n  mutate(pop = pop / 10^6)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp   pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8.43      779.\n 2 Afghanistan Asia       1957    30.3  9.24      821.\n 3 Afghanistan Asia       1962    32.0 10.3       853.\n 4 Afghanistan Asia       1967    34.0 11.5       836.\n 5 Afghanistan Asia       1972    36.1 13.1       740.\n 6 Afghanistan Asia       1977    38.4 14.9       786.\n 7 Afghanistan Asia       1982    39.9 12.9       978.\n 8 Afghanistan Asia       1987    40.8 13.9       852.\n 9 Afghanistan Asia       1992    41.7 16.3       649.\n10 Afghanistan Asia       1997    41.8 22.2       635.\n# ℹ 1,694 more rows\n\n\n\n Challenge 2\nUse mutate() to create a new column gdp_billion that has the absolute GDP (i.e., not relative to population size) in units of billions (i.e., 2.3 would mean 2.3 billion).\n\n\nClick for the solution\n\nYou need to do two things, which can be combined into a single line:\n\nMake the GDP absolute by multiplying by the population size: gdpPercap * pop\nChange the unit of the absolute GDP to billions by dividing by a billion: / 10^9\n\n\ngapminder |&gt;\n    mutate(gdp_billion = gdpPercap * pop / 10^9)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap gdp_billion\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n# ℹ 1,694 more rows"
  },
  {
    "objectID": "3_dplyr.html#summarize-to-compute-summary-stats",
    "href": "3_dplyr.html#summarize-to-compute-summary-stats",
    "title": "Data wrangling with dplyr",
    "section": "8 summarize() to compute summary stats",
    "text": "8 summarize() to compute summary stats\nThe final function dplyr function we’ll cover is summarize(), which computes summaries of your data across rows. For example, to calculate the mean GDP across the entire dataset (all rows):\n\n# The syntax is similar to 'mutate': &lt;new-column&gt; = &lt;operation&gt;\ngapminder |&gt;\n  summarize(mean_gdp = mean(gdpPercap))\n\n# A tibble: 1 × 1\n  mean_gdp\n     &lt;dbl&gt;\n1    7215.\n\n\nThe output is still a dataframe, but unlike with all previous dplyr functions, it is completely different from the input dataframe, “collapsing” the data down to as little as a single number, like above.\nsummarize() becomes really powerful in combination with the helper function group_by() to compute groupwise stats. For example, to get the mean GDP separately for each continent:\n\ngapminder |&gt;\n  group_by(continent) |&gt;\n  summarize(mean_gdp = mean(gdpPercap))\n\n# A tibble: 5 × 2\n  continent mean_gdp\n  &lt;fct&gt;        &lt;dbl&gt;\n1 Africa       2194.\n2 Americas     7136.\n3 Asia         7902.\n4 Europe      14469.\n5 Oceania     18622.\n\n\ngroup_by() implicitly splits a data frame into groups of rows: here, one group for observations from each continent. After that, operations like in summarize() will happen separately for each group, which is how we ended up with per-continent means.\n\n Challenge 3\nCalculate the average life expectancy per country. Which country has the longest average life expectancy and which has the shortest average life expectancy?\n\n\nClick for some hints\n\n\nSince you’ll need to examine your output in two ways, it makes sense to store the output of the life expectancy calculation in a dataframe.\nNext, an easy way to get rows with lowest and highest values in a column is to simply sort by that column and examining the output.\n\n\n\n\nClick for the solution\n\nFirst, create a dataframe with the mean life expectancy by country:\n\nlifeExp_bycountry &lt;- gapminder |&gt;\n   group_by(country) |&gt;\n   summarize(mean_lifeExp = mean(lifeExp))\n\nThen, arrange that dataframe in two directions to see the countries with the longest and shortest life expectancy. You could optionally pipe into head() to only see the top n, here top 1:\n\nlifeExp_bycountry |&gt;\n   arrange(mean_lifeExp) |&gt;\n   head(n = 1)\n\n# A tibble: 1 × 2\n  country      mean_lifeExp\n  &lt;fct&gt;               &lt;dbl&gt;\n1 Sierra Leone         36.8\n\nlifeExp_bycountry |&gt;\n   arrange(desc(mean_lifeExp)) |&gt;\n   head(n = 1)\n\n# A tibble: 1 × 2\n  country mean_lifeExp\n  &lt;fct&gt;          &lt;dbl&gt;\n1 Iceland         76.5"
  },
  {
    "objectID": "3_dplyr.html#bonus-material-for-self-study",
    "href": "3_dplyr.html#bonus-material-for-self-study",
    "title": "Data wrangling with dplyr",
    "section": "9 Bonus material for self-study",
    "text": "9 Bonus material for self-study\n\n9.1 Writing and reading tabular data to and from files\nWhen working with your own data in R, you’ll usually need to read data from files into your R environment, and conversely, to write data that is in your R environment to files.\nWhile it’s possible to make R interact with Excel spreadsheet files7, storing your data in plain-text files generally benefits reproducibility. Tabular plain text files can be stored using:\n\nA Tab as the column delimiter (often called TSV files, and stored with a .tsv extension)\nA comma as the column delimiter (often called CSV files, and stored with a .csv extension).\n\nTo practice writing and reading data to and from TSV files, the examples below use functions from the readr package. This package is part of the core tidyverse and therefore already loaded into your environment.\n\nWriting to files\nTo write the gapminder data frame to a TSV file, use the write_tsv() function with argument x for the R object and argument file for the file path:\n\nwrite_tsv(x = gapminder, file = \"gapminder.tsv\")\n\nBecause we simply provided a file name, the file will have been written in your R working directory8.\nIf you want to take a look at the file you just created, you can find it in RStudio’s Files tab and click on it, which will open it in the editor panel. Of course, you could also find it in your computer’s file browser and open it in different ways.\n\n\n\n\n\n\nNoteWant to write to a different folder on your computer? (Click to expand)\n\n\n\n\n\nThe file argument to write_tsv() takes a file path, meaning that you can specify any location on your computer for it, in addition to the file name.\nFor example, if you had a folder called results in your current working directory, you could save the file in there like so:\n\nwrite_tsv(x = gapminder, file = \"results/gapminder.tsv\")\n\nNote that a forward slash / as a folder delimiter will work regardless of your operating system (even though Windows natively delimits folder by a backslash \\).\nFinally, if you want to store the file in a totally different place than your working dir, it’s good to know that you can also use a so-called absolute (or “full”) path. For example:\n\nwrite_tsv(x = gapminder, file = \"/Users/poelstra.1/Desktop/gapminder.tsv\")\n\n\n\n\n\n\nReading from files\nTo practice reading data from a file, use the read_tsv() function on the file you just created:\n\ngapminder_reread &lt;- read_tsv(file = \"gapminder.tsv\")\n\nRows: 1704 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): country, continent\ndbl (4): year, lifeExp, pop, gdpPercap\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nNote that this function is rather chatty, telling you how many rows and columns it read, and what their data types are. Let’s check the resulting object:\n\ngapminder_reread\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nThis looks good! Do note that the column’s data types are not identical to what they were (year and pop are saved as double rather than integer, and country and continent as character rather than factor). This is largely expected because that kind of metadata is not stored in a plain-text TSV, so read_tsv() will by default simply make best guesses as to the types.\nAlternatively, you could tell read_tsv() what the column types should be, using the col_types argument (with abbreviations f for factor, i for integer, d for double — run ?read_tsv for more info):\n\nread_tsv(file = \"gapminder.tsv\", col_types = \"ffidi\")\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\nTo read and write CSV files instead, use read_csv() / write_csv() in the same way.\n\n\n\n\n\n\n9.2 Counting rows with count() and n()\nA common operation is simply counting the number of observations for each group. The dplyr package comes with two related functions that help with this.\nFor instance, to check the number of countries included in the dataset for the year 2002, you can use the count() function. It takes the name of one or more columns to define the groups we are interested in, and can optionally sort the results in descending order with sort = TRUE:\n\ngapminder |&gt;\n    filter(year == 2002) |&gt;\n    count(continent, sort = TRUE)\n\n# A tibble: 5 × 2\n  continent     n\n  &lt;fct&gt;     &lt;int&gt;\n1 Africa       52\n2 Asia         33\n3 Europe       30\n4 Americas     25\n5 Oceania       2\n\n\nIf you need to use the number of observations in calculations, the n() function is useful. It will return the total number of observations in the “current group” as applicable – for instance, to get the standard error of life expectancy per continent:\n\ngapminder |&gt;\n  group_by(continent) |&gt;\n  summarize(se_life = sd(lifeExp) / sqrt(n()))\n\n# A tibble: 5 × 2\n  continent se_life\n  &lt;fct&gt;       &lt;dbl&gt;\n1 Africa      0.366\n2 Americas    0.540\n3 Asia        0.596\n4 Europe      0.286\n5 Oceania     0.775\n\n\n\n\n9.3 Function name conflicts\nWhen you loaded the tidyverse, the output included a “Conflicts” section that may have seemed ominous:\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nWhat this means is that two tidyverse functions, filter() and lag(), have the same names as two functions from the stats package that were already in your R environment.\nThose stats package functions are part of what is often referred to as “base R”: core R functionality that is always available (loaded) when you start R.\nDue to this function name conflict/collision, the filter() function from dplyr “masks” the filter() function from stats. Therefore, if you write a command with filter(), it will use the dplyr function and not the stats function.\nYou can use a “masked” function, by prefacing it with its package name as follows: stats::filter().\n\n\n9.4 Using the pipe keyboard shortcut\nThe following RStudio keyboard shortcut will insert a pipe symbol: Ctrl/Cmd + Shift + M.\nHowever, by default this (still) inserts an older pipe symbol, %&gt;%. As long as you’ve loaded the tidyverse9, it would not really be a problem to just use %&gt;% instead of |&gt;. But it would be preferred to make RStudio insert the |&gt; pipe symbol:\n\nClick Tools &gt; Global Options &gt; Code tab on the right\nCheck the box “Use native pipe operator” as shown below\nClick OK at the bottom of the options dialog box to apply the change and close the box.\n\n\n\n\n\n\n\n\n9.5 Learn more\nThe material in this page was adapted from this Carpentries lesson episode, which has a lot more content than we were able to cover today.\nRegarding data wrangling specifically, here are two particularly useful additional skills to learn:\n\nPivoting/reshaping — moving between ‘wide’ and ‘long’ data formats with pivot_wider() and pivot_longer(). This is covered in episode 13 of the focal Carpentries lesson.\nJoining/merging — combining multiple dataframes based on one or more shared columns. This can be done with dplyr’s join_*() functions – see for example this chapter in R for Data Science."
  },
  {
    "objectID": "3_dplyr.html#footnotes",
    "href": "3_dplyr.html#footnotes",
    "title": "Data wrangling with dplyr",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n Or Click File =&gt; New file =&gt; R Script.↩︎\n If not: run install.packages(\"tidyverse\") now.↩︎\n If not: run install.packages(\"gapminder\") now.↩︎\n Based on what you learned in the previous session, it may seem strange that the column names should not be quoted. One way to make sense of this is that the columns can be thought of as (vector) objects, whose names are the column names.↩︎\n Using pipes is also faster and uses less computer memory.↩︎\n It will always rearrange the order of rows as a whole, never just of individual columns since that would scramble the data.↩︎\n Using the readxl package. This is installed as part of the tidyverse but is not a core tidyverse package and therefore needs to be loaded separately: library(readxl).↩︎\n Recall that you can see where that is at the top of the Console tab, or by running getwd().↩︎\n This symbol only works when you have one of the tidyverse packages loaded.↩︎"
  },
  {
    "objectID": "4_ggplot.html",
    "href": "4_ggplot.html",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "",
    "text": "In this episode, we will learn about how to create publication-quality graphics in R using the tidyverse package ggplot2. Plotting data is a very quick and easy way to understand the relationship between your variables."
  },
  {
    "objectID": "4_ggplot.html#the-grammar-of-graphics",
    "href": "4_ggplot.html#the-grammar-of-graphics",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "1 The grammar of graphics",
    "text": "1 The grammar of graphics\nThe package ggplot2 applies a framework for plotting such that any plot can be built from the same basic building blocks. This very popular package is based on a system called the Grammar of Graphics by Leland Wilkinson which aims to create a grammatical rules for the development of graphics. It is part of a larger group of packages called “the tidyverse.”\nThe “gg” in ggplot stands for “grammar of graphics” and all plots share a common template. This is fundamentally different than plotting using a program like Excel, where you first pick your plot type, and then you add your data. With ggplot, you start with data, add a coordinate system, and then add “geoms,” which indicate what type of plot you want. A cool thing about ggplot is that you can add and layer different geoms together, to create a fully customized plot that is exactly what you want. If this sounds nebulous right now, that’s okay, we are going to talk more about this.\nSimplified, we will provide to R:\n\nour data\naesthetics mapped to variables - what connects the data to the graphics\nlayers - determine which type of plot we are going to make, what coordinate system we will use, what scales we want, and other important aspects of our plot\n\nYou can think about a ggplot as being composed of layers. You start with your data, and continue to add layers until you get the plot that you want. This might sound a bit abstract so I am going to talk through this with an example."
  },
  {
    "objectID": "4_ggplot.html#looking-at-our-data-and-getting-set-up",
    "href": "4_ggplot.html#looking-at-our-data-and-getting-set-up",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "2 Looking at our data and getting set up",
    "text": "2 Looking at our data and getting set up\n\n2.1 Setting up\nTo make it easier to keep track of what we do, we’ll write our code in a script (and send it to the console from there) – here is how to create and save a new R script:\n\nOpen a new R script (Click the + symbol in toolbar at the top, then click R Script)1.\nSave the script straight away as ggplot.R – you can save it anywhere you like, though it is probably best to save it in a folder specifically for this workshop.\nIf you want the section headers as comments in your script, as in the script I am showing you now, then copy-and-paste the following into your script:\n\n\n\nSection headers for your script (Click to expand)\n\n\n# 2 Looking at our data and getting set up--------------------------------------\n\n\n\n# 3 Building our plot-----------------------------------------------------------\n\n\n\n## Challenge 1------------------------------------------------------------------\n# Modify the plot we’ve made so that you can see the relationship between life \n# expectancy and year.\n\n\n\n## Challenge 2------------------------------------------------------------------\n# Modify to color your points by continent.\n\n\n# 4 Adding more layers----------------------------------------------------------\n\n\n\n## Challenge 3------------------------------------------------------------------\n# Change the order of the point and line layers - what happens?\n\n\n\n# 5 Transformations and statistics----------------------------------------------\n\n\n\n## Challenge 4A-----------------------------------------------------------------\n# Modify the color and the size of the points in the previous example. \n# You’ll also probably want to make the linewidth less ridiculous.\n\n\n## Challenge 4B-----------------------------------------------------------------\n# Modify the plot from 4A so points are a different shape \n# and colored by continent with new trendlines\n\n\n# 6 Multi-panel figures---------------------------------------------------------\n\n\n\n# 7 Modifying text--------------------------------------------------------------\n\n\n\n# 8 Adjusting theming-----------------------------------------------------------\n\n\n\n# 9 Exporting a plot------------------------------------------------------------\n\n\n\n## Challenge 5------------------------------------------------------------------\n\n# Create some box plots that compare life expectancy between the continents over \n# the time period provided. Try and make your plot look nice, add labels \n# and adjust the theme!\n\n\n\nBefore we plot, let’s look at the data we will use for this session. We are going to use the same gapminder data from one hour ago.\nIn case you don’t have it up from before, let’s load both the tidyverse and gapminder using the function library() so they are active.\n\nlibrary(tidyverse)\n\nWarning: package 'ggplot2' was built under R version 4.5.2\n\n\nWarning: package 'tidyr' was built under R version 4.5.2\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(gapminder)\n\nWe can use the function View() to look at our data. This opens our data sort of like how we might view it in Excel.\n\nView(gapminder)\n\nWe can also use the function str() or glimpse() to look at the structure of our data.\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\ngapminder is a tibble (very similar to a data frame), comprised of 1,704 rows and 6 columns. The columns are:\n\ncountry (a factor)\ncontinent (a factor)\nyear (an integer)\nlifeExp (a number)\npop (an integer)\n\nWe are going to use the function ggplot() when we want to make a ggplot.\n\n\n\n\n\n\nTipThe function vs the package\n\n\n\nNote, the function is called ggplot() and the package is called ggplot2.\n\n\nIf we want to learn how the function works, we can use the ? to find out more. Running the code below will open up the documentation page for the function ggplot() in the bottom right “Help” quadrant of RStudio.\n\n?ggplot()"
  },
  {
    "objectID": "4_ggplot.html#building-our-plot",
    "href": "4_ggplot.html#building-our-plot",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "3 Building our plot",
    "text": "3 Building our plot\nWe can start by providing the data as the first argument to ggplot().\n\nggplot(data = gapminder)\n\n\n\n\n\n\n\n\nWe have a blank plot! We haven’t given enough information for R to know what we want to plot - we have simply told R what dataframe we will be using. We are getting the first “base” layer of the plot.\nInstead of providing the dataframe as the first argument to ggplot(), we can use the pipe |&gt; (or the old pipe %&gt;% that you might see around, which works in the exact same way) that Jelmer taught us about. This “sends” the data into the next function. I will use this syntax for the rest of the workshop.\n\ngapminder |&gt;\n  ggplot()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nggplot(data = gapminder) and gapminder |&gt; ggplot() are the same thing.\n\n\nIf we want to make a scatterplot to understand the relationship between GDP per capita (i.e., gdpPercap) and life expectancy (i.e., lifeExp), we can do so by setting x and y respectively within aes(), or our aesthetic mappings.\n\ngapminder |&gt;\n  ggplot(mapping = aes(x = gdpPercap, y = lifeExp))\n\n\n\n\n\n\n\n\nOk! We don’t have a plot, per se, but we have more than we had before. We can now see that gdpPercap is on the x-axis (along with some numbers reflecting the range of our data), and lifeExp is on the y-axis (along with some numbers reflecting the range of our data).\n\n\n\n\n\n\nNote\n\n\n\nNote that the “mapping” part is actually not necessary.\n\n\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp))\n\n\n\n\n\n\n\n\nNow we need to tell R what geometry, or “geom” want to use. All of the “geoms” start with geom_*(), and we can see what they all are by starting to type geom and pressing tab.\nLet’s make a scatterplot here.\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n3.1 Challenge 1\nModify the plot we’ve made so that you can see the relationship between life expectancy and year.\n\n\nClick for the solution\n\nMap x = year and y = lifeExp, and use geom_point() since we want a scatterplot.\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nNote the plot looks a little weird since each point is a country, so for every year, we have an average life expectancy for each country.\n\n\n\n\n3.2 Challenge 2\nModify to color your points by continent.\n\n\nNeed a hint?\n\nTry using the argument color within your aesthetic mappings.\n\n\n\nNeed another hint?\n\nTry setting color = continent within your aesthetic mappings.\n\n\n\nClick for the solution\n\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = lifeExp, color = continent)) + \n  geom_point()\n\n\n\n\n\n\n\n\nYou can better see here that each point is actually a different country now that they are colored by continent."
  },
  {
    "objectID": "4_ggplot.html#adding-more-layers",
    "href": "4_ggplot.html#adding-more-layers",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "4 Adding more layers",
    "text": "4 Adding more layers\nInstead of making a scatter plot, we might want to make a line plot. Using ggplot this is as easy as changing out your geom.\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = lifeExp, color = continent)) +\n  geom_line()\n\n\n\n\n\n\n\n\nThe plot is jumping around a lot since for each year, we have life expectancy data for each country. Our plot here is not a summary of that data, but instead all of that data together, on top of itself.\nWe might want to have one line for each country, we can do this by specifying group = country within our aesthetic mappings.\n\ngapminder |&gt; \n  ggplot(aes(x = year, y = lifeExp, color = continent, group = country)) +\n  geom_line()\n\n\n\n\n\n\n\n\nA nice thing about ggplot is that you don’t actually need to decide if you want to have lines or points, you can have both!\n\ngapminder |&gt; \n  ggplot(aes(x = year, y = lifeExp, color = continent, group = country)) +\n  geom_line() +\n  geom_point()\n\n\n\n\n\n\n\n\nNow we see a point for each observation and each point and line is colored based on continent.\nYou can also set your mappings globally (within ggplot()) or locally (within a specific geom). Let’s see what the difference is. Let’s see what happens when we move color = continent into geom_point(aes(color = continent)).\n\ngapminder |&gt; \n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_point(aes(color = continent)) +\n  geom_line()\n\n\n\n\n\n\n\n\nWe can see that now only the points are colored by continent, and the lines are all black (the default color for one group).\n\n\n4.1 Challenge 3\nChange the order of the point and line layers - what happens?\n\n\nClick for the solution\n\nPoints then lines (points are on the bottom)\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_point() +\n  geom_line(aes(color = continent))\n\n\n\n\n\n\n\n\nLines then points (lines are on the bottom)\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_line(aes(color = continent)) +\n  geom_point() \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe layers are added in the order you indicate, so if you change the order, your plot will change. You can see because geom_line() comes below geom_point(), the lines are placed on top of the points."
  },
  {
    "objectID": "4_ggplot.html#transformations-and-statistics",
    "href": "4_ggplot.html#transformations-and-statistics",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "5 Transformations and statistics",
    "text": "5 Transformations and statistics\nSometimes we might want to apply some kind of transformation to our data while plotting so we can better see relationships between our variables.\nLet’s start with a base plot to see the relationship between GDP per capita (gdpPercap) and life expectancy (lifeExp).\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThe presence of some outliers for gdpPercap make it hard to see this relationship. We can try log base 10 transforming the x-axis to see if this helps using a scale_*() function.\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10() # log 10 scales the x axis\n\n\n\n\n\n\n\n\nI can also make our points a little bit transparent to ease our overplotting problem (where too many point are on top of each other, making each point hard to see) by setting alpha =. Alpha ranges from 0 (totally transparent) to 1 (totally opaque). Note that I alpha = 0.5 outside the aes() function - we are not mapping alpha to some variable, we are simply setting what alpha should be.\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + # not inside aes\n  scale_x_log10() # log10 transform the x-axis\n\n\n\n\n\n\n\n\nNow we can better see the parts of the plot that are very dark are where there are a lot of data points.\nWe can also add a smoothed line of fit to our data by setting method = \"lm\" within geom_smooth() to fit a linear model.\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + # not inside the aes\n  scale_x_log10() +\n  geom_smooth(method = \"lm\") # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nWe can adjust the thickness of the line by setting linewidth within geom_smooth(), and turn off the confidence interval by setting se = FALSE.\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) + # not inside the aes\n  scale_x_log10() +\n  geom_smooth(method = \"lm\", # smooth with a linear model ie \"lm\"\n              linewidth = 3, # increase thickness of the line\n              se = FALSE) # turn off plotting of a confident internal\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n5.1 Challenge 4A\nModify the color and the size of the points in the previous example. You’ll also probably want to make the linewidth less ridiculous.\n\n\nNeed a hint?\n\nDon’t put color and size inside aes().\n\n\n\nWant another hint?\n\nThe equivalent of linewidth for points is size.\n\n\n\nClick for the solution\n\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5, color = \"purple\", size = 0.5) + # outside the aes\n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.2 Challenge 4B\nModify the plot from 4A so points are a different shape and colored by continent with new trendlines\n\n\nNeed a hint?\n\nDon’t put color and size inside aes().\n\n\n\nWant another hint?\n\nThe equivalent of linewidth for points is size.\n\n\n\nClick for the solution\n\nAll points are now triangles. You can find info on the shape codes here.\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(shape = 17, # 17 is a closed triangle\n             alpha = 0.5) + \n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nAll points are now open triangles, we are setting continent to fill and making the outline black. Note that only shapes 21-25 can accept both a color (outside) and fill (inside). Otherwise, they only accept color.\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp, fill = continent)) +\n  geom_point(shape = 24, # open triangle\n             alpha = 0.5, \n             color = \"black\") + # color controls outside, fill controls inside\n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nMapping shape to continent\n\ngapminder |&gt;\n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(aes(shape = continent), alpha = 0.5) + \n  scale_x_log10() +\n  geom_smooth(method = \"lm\", linewidth = 1) # smooth with a linear model ie \"lm\"\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "4_ggplot.html#multi-panel-figures",
    "href": "4_ggplot.html#multi-panel-figures",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "6 Multi-panel figures",
    "text": "6 Multi-panel figures\nSmall multiples are a useful way to look at data across the same scale to understand patterns.\nLet’s say we want to understand how life expectancy changes over time throughout the Americas? Instead of making an individual plot for each country, we can use facet_wrap() to have ggplot make our plots all at once.\nFirst let’s use what Jelmer taught us to filter for only the observations from the Americas.\n\ngapminder_americas &lt;- gapminder |&gt;\n  filter(continent == \"Americas\")\n\nThen, this new data frame gapminder_americas can be the data for our next plot. Let’s look first without faceting.\n\ngapminder_americas |&gt;\n  ggplot(aes(x = year, y = lifeExp, group = country)) +\n  geom_line()\n\n\n\n\n\n\n\n\nFaceting allows us to better see each country on its own.\n\ngapminder_americas |&gt;\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country))  # make facets by country"
  },
  {
    "objectID": "4_ggplot.html#modifying-text",
    "href": "4_ggplot.html#modifying-text",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "7 Modifying text",
    "text": "7 Modifying text\nThe plots we’ve made so far could really benefit from some better labels. We can set what we want or plot labels to be as arguments in labs().\n\ngapminder_americas |&gt;\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country)) + # make facets by country\n  labs(x = \"Year\",              # x axis title\n       y = \"Life expectancy\",   # y axis title\n       title = \"Figure 1. Life expectancy in the Americas from 1952-2007\", # main title of figure\n      )"
  },
  {
    "objectID": "4_ggplot.html#adjusting-theming",
    "href": "4_ggplot.html#adjusting-theming",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "8 Adjusting theming",
    "text": "8 Adjusting theming\nWe can also modify the non-data elements on our plot by controlling the theming. We can do this in two general ways:\n\nby selecting a pre-set (or “complete”) theme, functions start with theme_*()\nby modifying individual settings using the function theme()\n\nWe will start with the pre-set themes by adding this function to the end of our ggplot code.\n\ngapminder_americas |&gt;\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country)) + # make facets by country\n  theme(axis.text.x = element_text(angle = 45)) + # years on the x on a 45 deg angle\n  labs(x = \"Year\",              # x axis title\n       y = \"Life expectancy\",   # y axis title\n       title = \"Figure 1. Life expectancy in the Americas from 1952-2007\", # main title of figure\n      ) +\n  theme_bw() # change to a black and white theme\n\n\n\n\n\n\n\n\nIf we wanted to change the fonts, change the color the strip text (i.e., the text in the rectangle behind the names of the countries), the strip text background (i.e., the rectangle behind the names of the countries), adjust the x-axis year labels to be on an angle so they’re not so squished, we can do all that.\n\ngapminder_americas |&gt;\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country)) + # make facets by country\n  theme(axis.text.x = element_text(angle = 45)) + # years on the x on a 45 deg angle\n  labs(x = \"Year\",              # x axis title\n       y = \"Life expectancy\",   # y axis title\n       title = \"Figure 1. Life expectancy in the Americas from 1952-2007\", # main title of figure\n      ) +\n  theme_bw() + # change to a black and white theme\n  theme(text = element_text(family = \"AppleGothic\"), # change all fonts\n        strip.background = element_rect(color = \"red\", fill = \"black\"), # strip text outline red, fill black\n        strip.text = element_text(color = \"white\"), # strip text white\n        axis.text.x = element_text(angle = 45, # years on the x on a 45 deg angle\n                                   vjust = 0.7)) # scoot year numbers down a lil\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemember that your code is run from top to bottom, so if code lower down over-writes something that came above, the lower code will prevail."
  },
  {
    "objectID": "4_ggplot.html#exporting-a-plot",
    "href": "4_ggplot.html#exporting-a-plot",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "9 Exporting a plot",
    "text": "9 Exporting a plot\nOften we want to take our plot we have made using R and save it for use someplace else. You can export using the Export button in the Plots pane (bottom right) but you are limited on the parameters for the resulting figure.\nWe can do this with more control using the function ggsave().\nFirst we will save our plot as an object using the assignment operator &lt;-, here as life_exp_americas_plot.\n\nlife_exp_americas_plot &lt;- gapminder_americas |&gt;\n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line() +\n  facet_wrap(vars(country)) + # make facets by country\n  theme(axis.text.x = element_text(angle = 45)) + # years on the x on a 45 deg angle\n  labs(x = \"Year\",              # x axis title\n       y = \"Life expectancy\",   # y axis title\n       title = \"Figure 1. Life expectancy in the Americas from 1952-2007\", # main title of figure\n      ) +\n  theme_bw() + # change to a black and white theme\n  theme(text = element_text(family = \"AppleGothic\"), # change all fonts\n        strip.background = element_rect(color = \"red\", fill = \"black\"), # strip text outline red, fill black\n        strip.text = element_text(color = \"white\"), # strip text white\n        axis.text.x = element_text(angle = 45, # years on the x on a 45 deg angle\n                                   vjust = 0.7)) # scoot year numbers down a lil\n\nThen we can save it. I am indicating here to save the plot in a folder called results in my working directory, as a file called lifeExp.png. If you want your file to go within a folder, you have to first create that folder.\n\nggsave(filename = \"results/lifeExp.png\", # file path and name\n       plot = life_exp_americas_plot,  # what to save\n       width = 18, \n       height = 12, \n       dpi = 300, # dots per inch,  ie resolution\n       units = \"cm\") # units for width and height\n\n\n\n\n\n\n\nNote\n\n\n\nTo learn more about the arguments in ggsave() you can always run ?ggsave().\n\n\n\n9.1 Challenge 5\nCreate some box plots that compare life expectancy between the continents over the time period provided. Try and make your plot look nice, add labels and adjust the theme!\n\n\nNeed a hint?\n\nThe geom for making a boxplot is geom_boxplot().\n\n\n\nWant another hint?\n\nSet labels within labs(). Adjust theming with theme(). Check out the complete themes.\n\n\n\nClick for the solution\n\n\ngapminder |&gt;\n  ggplot(aes(x = continent, y = lifeExp, fill = continent)) +\n  geom_boxplot() +\n  facet_wrap(vars(year)) +\n  theme_classic() + # my favorite complete theme \n  theme(axis.title.x = element_blank(), # remove x-axis title\n        axis.text.x = element_blank(), # remove x-axis labels\n        axis.ticks.x = element_blank()) + # remove x-axis ticks\n  labs(y = \"Life Expectancy (years)\",\n       fill = \"Continent\") # change the label on top of the legend"
  },
  {
    "objectID": "4_ggplot.html#footnotes",
    "href": "4_ggplot.html#footnotes",
    "title": "Creating publication quality graphics with ggplot2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n Or Click File =&gt; New file =&gt; R Script.↩︎"
  },
  {
    "objectID": "1_intro.html#overview",
    "href": "1_intro.html#overview",
    "title": "Introduction to R and RStudio",
    "section": "1 Overview",
    "text": "1 Overview\n\n1.1 This session\nIn this session, we will learn how to find your way around RStudio, how to interact with R, how to manage your R environment, and how to install packages. Our objectives include:\n\nDescribing the purpose and use of each pane in RStudio\nLocating buttons and options in RStudio\nDefining a variable/object\nAssigning data to a variable/object\nManaging a workspace in an interactive R session\nUsing mathematical and comparison operators\nCalling functions\nManaging packages\nGetting help in R\n\nBy the end of this session, you will be well-equipped with the foundational skills needed to navigate RStudio and effectively interact with R.\n\n\n1.2 The rest of today\nWe will begin with raw data, perform exploratory analyses, and learn how to plot results graphically. This example starts with a dataset from gapminder.org containing population information for many countries through time. Can you read the data into R? Can you plot the population for Senegal? Can you calculate the average income for countries on the continent of Asia? By the end of these lessons you will be able to do things like plot the populations for all of these countries in under a minute!"
  },
  {
    "objectID": "1_intro.html#why-use-r-and-r-studio",
    "href": "1_intro.html#why-use-r-and-r-studio",
    "title": "Introduction to R and RStudio",
    "section": "2 Why use R and R studio?",
    "text": "2 Why use R and R studio?\nScience is a multi-step process: once you’ve designed an experiment and collected data, the real fun begins with analysis! In this lesson, we will teach you some of the fundamentals of the R language and share best practices for organizing code in scientific projects, which will make your life easier.\nThough we could use a spreadsheet in Microsoft Excel or Google Sheets to analyze our data, these tools have limitations in terms of flexibility and accessibility. Moreover, they make it difficult to share the steps involved in exploring and modifying raw data, which is essential for conducting “reproducible” research.\nTherefore, this lesson will guide you on how to start exploring your data using R. R is a program available for Windows, Mac, and Linux operating systems, and can be freely downloaded from the link provided above. To run R, all you need is the R program.\nHowever, we will be running R inside a fancy editor (or “IDE”, Integrated Development Environment) called RStudio, which makes working with R much more pleasant!\nSince R is open source, there are endlessly available free resource to learn how to do practically whatever you want on the internet."
  },
  {
    "objectID": "1_intro.html#orienting-to-rstudio-basic-layout",
    "href": "1_intro.html#orienting-to-rstudio-basic-layout",
    "title": "Introduction to R and RStudio",
    "section": "3 Orienting to RStudio (basic layout)",
    "text": "3 Orienting to RStudio (basic layout)\nWhen you first open RStudio, you will be greeted by three panels:\n\nLeft: the default tab in this panel is your R “Console”, where you can type and execute R code (if you’ve previously used standalone R without RStudio, all that would be shown is this type of console).\nTop right: the default tab in this panel this is your “Environment”, which shows you all the objects that are active in your R environment.\nBottom right: the default tab in this panel is “Files”, showing the files in your working directory (more about that next). There are also additional tabs to e.g. show plots, packages, and help, some of which we’ll see later today.\n\n\n\n\n\n\n\n\n\n\n\n\nClick here for a useful RStudio cheatsheet"
  },
  {
    "objectID": "1_intro.html#r-as-calculator",
    "href": "1_intro.html#r-as-calculator",
    "title": "Introduction to R and RStudio",
    "section": "4 R as calculator",
    "text": "4 R as calculator\nTo get used to typing and executing R code, we’ll simply use R as a calculator – type 5 + 5 in the console and press Enter:\n\n#Addition\n5 + 5\n\n[1] 10\n\n\nR will print the result of the calculation, 10. The result is prefaced by [1], which is simply an index/count of outputs, because sometimes R can output hundreds of numbers or other elements.\nMore examples\n\n# Subtraction\n15 - 4\n\n[1] 11\n\n\n\n# Multiplication\n6 * 8\n\n[1] 48\n\n\n\n# Division\n40 / 5\n\n[1] 8\n\n\n\n# Exponents\n3 ^ 4\n\n[1] 81\n\n\n\n# Square root (using exponent 0.5)\n16 ^ 0.5\n\n[1] 4\n\n\n\n# Parentheses change order of operations\n(5 + 3) * 2\n\n[1] 16\n\n\n\n# Without parentheses, multiplication happens first\n5 + 3 * 2\n\n[1] 11\n\n\n\n# Multiple operations in one line\n10 - 2 + 4 * 3\n\n[1] 20\n\n\n\n# Using ** as an alternative exponent operator\n2 ** 5\n\n[1] 32\n\n\n\n\n\n\n\n\nNoteOrder of operations\n\n\n\nWhen using R as a calculator, the order of operations is the same as you would have learned back in school. From highest to lowest precedence:\n\nParentheses: (, )\nExponents: ^ or **\nMultiply: *\nDivide: /\nAdd: +\nSubtract: -"
  },
  {
    "objectID": "1_intro.html#the-r-prompt",
    "href": "1_intro.html#the-r-prompt",
    "title": "Introduction to R and RStudio",
    "section": "5 The R prompt",
    "text": "5 The R prompt\nThe &gt; sign in your console is the R “prompt”. It indicates that R is ready for you to type something.\nWhen you are not seeing the &gt; prompt, R is either busy (because you asked it to do a longer-running computation) or waiting for you to complete an incomplete command.\nIf you notice that your prompt turned into a +, you typed an incomplete command – for example:\n\n10 /\n\n+\nTo get out of this situation, one option is to try and finish the command (in this case, by typing another number) — but here, let’s practice another option: aborting the command by pressing Esc."
  },
  {
    "objectID": "1_intro.html#r-scripts",
    "href": "1_intro.html#r-scripts",
    "title": "Introduction to R and RStudio",
    "section": "6 R scripts",
    "text": "6 R scripts\nOnce you open a file, a new RStudio panel will appear in the top-left, where you can view and edit text files, most commonly R scripts (.R). An R script is a text file that contains R code.\nCreate and open a new R script by clicking File (top menu bar) &gt; New File &gt; R Script.\n\nWhy use a script?\nIt’s a good idea to write and save most of our code in scripts, instead of directly in the R console. This helps us keep track of what we’ve been doing, especially in the longer run, and to re-run our code after modifying input data or one of the lines of code.\n\n\nSending code to the console\nTo send code from the editor to the console, where it will be executed by R, press Ctrl + Enter (or, on a Mac: Cmd + Enter) with the cursor anywhere in a line of code in the script.\nPractice that after typing the following command in the script:\n\n5 + 5\n\n[1] 10"
  },
  {
    "objectID": "1_intro.html#adding-comments-to-your-code",
    "href": "1_intro.html#adding-comments-to-your-code",
    "title": "Introduction to R and RStudio",
    "section": "7 Adding comments to your code",
    "text": "7 Adding comments to your code\nYou can use # signs to comment your code.\n\nAnything to the right of a # is ignored by R, meaning it won’t be executed.\nYou can use # both at the start of a line (entire line is a comment) or anywhere in a line following code (rest of the line is a comment).\nIn your R script, comments are formatted differently so you can clearly distinguish them from code.\n\nSee the example below:\n\n# This line is entirely ignored by R\n10 / 5  # This line contains code but everythig after the '#' is ignored\n\n[1] 2"
  },
  {
    "objectID": "1_intro.html#functions-in-r-and-packages",
    "href": "1_intro.html#functions-in-r-and-packages",
    "title": "Introduction to R and RStudio",
    "section": "8 Functions in R – and packages",
    "text": "8 Functions in R – and packages\nTo do almost anything in R, you will use “functions” (these are like commands).\nYou can recognize function calls by the parentheses, like in install.packages(). Inside those parentheses, you can provide arguments to a function.\nFor example, install.packages() is an important function you already used if you followed the setup instructions for this workshop: it will install an R package. R packages are basically add-ons or extensions to the functionality of the R language. Inside the parenthese of install.packages(), you should provide a package name as an argument, like install.packages(\"gapminder\").\nAnother example of an R function is library(), which will access your “library” of installed packages to load a package. Every time you want to use a package in R, you need to load it, just like everytime you want to use MS Word on your computer, you need to open it.\nLet’s see if you have the two packages that we will use today installed:\n\nlibrary(gapminder)\n# (No output is expected if the package can be loaded)\n\n\n# (Output like that shown below is expected if the package can be loaded:)\nlibrary(tidyverse)\n\nWarning: package 'ggplot2' was built under R version 4.5.2\n\n\nWarning: package 'tidyr' was built under R version 4.5.2\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf you got an error when trying to load one or both of these packages, you’ll need to install those:\n\n# ONLY run this if you got errors above:\ninstall.packages(\"gapminder\")\ninstall.packages(\"tidyverse\")\n\n\n8.1 Some other R functions\nAnother important function is c(), which stands for combine or concatenate. With c(), you can create vectors that contain multiple elements, like multiple numbers. You’ll learn more about vectors in the next session, but here is a quick example:\n\nc(10, 15)\n\n[1] 10 15\n\n\nBelow are examples of some other R functions:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nabs(x)\nabsolute value\n\n\nsqrt(x)\nsquare root\n\n\nround(x, digits=n)\nround(3.475, digits=2) is 3.48\n\n\nlog(x)\nnatural logarithm\n\n\nlog10(x)\ncommon logarithm"
  },
  {
    "objectID": "1_intro.html#comparing-things",
    "href": "1_intro.html#comparing-things",
    "title": "Introduction to R and RStudio",
    "section": "9 Comparing things",
    "text": "9 Comparing things\nIn R, you can use comparison operators to compare numbers. For example:\n\n# Greater than\n8 &gt; 3\n\n[1] TRUE\n\n\n\n# Less than\n2 &lt; 1\n\n[1] FALSE\n\n\n\n# Equal to\n7 == 7\n\n[1] TRUE\n\n\n\n# Not equal to\n10 != 5\n\n[1] TRUE\n\n\n\n# Greater than or equal to\n6 &gt;= 6\n\n[1] TRUE\n\n\n\n# Comparisons can be combined with arithmetic\n(3 + 4) == 7\n\n[1] TRUE\n\n\nHere are the most common comparison operators in R:\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n&gt;\nGreater than\n5 &gt; 6 returns FALSE\n\n\n&lt;\nLess than\n5 &lt; 6 returns TRUE\n\n\n==\nEquals to\n10 == 10 returns TRUE\n\n\n!=\nNot equal to\n10 != 10 returns FALSE\n\n\n&gt;=\nGreater than or equal to\n5 &gt;= 6 returns FALSE\n\n\n&lt;=\nLess than or equal to\n6 &lt;= 6 returns TRUE"
  },
  {
    "objectID": "1_intro.html#r-objects",
    "href": "1_intro.html#r-objects",
    "title": "Introduction to R and RStudio",
    "section": "10 R objects",
    "text": "10 R objects\n\n10.1 Assigning stuff to objects\nWe can assign one or more values to a so-called “object” with the assignment operator &lt;-. A few examples:\n\n# Assign the value 250 the object 'length_cm'\nlength_cm &lt;- 250\n\n# Assign the value 2.54 to the object 'conversion'\nconversion &lt;- 2.54\n\nTo see the contents of an object, you can simply print its name:\n\nlength_cm\n\n[1] 250\n\n\nImportantly, you can use objects as if you had typed their values directly:\n\nlength_cm / conversion\n\n[1] 98.4252\n\n\n\nlength_in &lt;- length_cm / conversion\nlength_in\n\n[1] 98.4252\n\n\n\n\n10.2 Object names\nSome pointers on object names:\n\nBecause R is case sensitive, length_inch is different from Length_Inch!\nAn object name cannot contain spaces — so for readability, you should separate words using:\n\nUnderscores: length_inch (this is called “snake case”)\nPeriods: wingspan.inch\nCapitalization: wingspanInch or WingspanInch (“camel case”)\n\nYou will make things easier for yourself by naming objects in a consistent way, for instance by always sticking to your favorite case style like “snake case.”\nObject names can contain but cannot start with a number: x2 is valid but 2x is not.\nMake object names descriptive yet not too long — this is not always easy!"
  },
  {
    "objectID": "1_intro.html#r-help-help-and",
    "href": "1_intro.html#r-help-help-and",
    "title": "Introduction to R and RStudio",
    "section": "11 R Help: help() and ?",
    "text": "11 R Help: help() and ?\nThe help() function and ? help operator in R offer access to documentation pages for R functions, data sets, and other objects. They provide access to both packages in the standard R distribution and contributed packages.\nFor example:\n?install.packages\nThe output should be shown in the Viewer tab of the bottom left RStudio panel, and look something like this:"
  },
  {
    "objectID": "1_intro.html#working-directories",
    "href": "1_intro.html#working-directories",
    "title": "Introduction to R and RStudio",
    "section": "12 Working directories",
    "text": "12 Working directories\n\n12.1 What is a directory and a working directory?\nUnderstanding directories and your working directory is crucial when coding.\nThe word “directory” is just a synonym for a computer folder. These folders have specific physical locations on your computer, known as paths. Directories are organized hierarchically, and the overall structure of standard directories differs slightly across various operating systems, such as Mac, Windows, and Linux. By using Finder (Mac) or File Explorer (Windows), you can navigate to different locations on your computer, but you can also do so using R code.\nYour working directory is exactly what it sounds like— it is the current location or path on your computer where you are actively working. This is important because, by default, your files will be read from, stored in, and saved to this location. Therefore, it is essential to know where your working directory is.\n\n\n12.2 Find your working directory\nWe can figure out where our working directory is by typing the function getwd() into the console:\ngetwd()\n[1] \"/Users/lopez-nicora.1\"\n\n\n\n\n\n\nWarningDirectories are separated by / on Mac and by \\ on Windows\n\n\n\nBecause I am using a Mac, directories in my path are separated by forward slashes /, while on Windows machines, they are separated by backslashes \\.\nThat said, when you provide a path to R, like we’ll do below with setwd(), you can use forward slashes on all operating systems!\n\n\n\n\n12.3 Set your working directory\nIf your working directory is not where you want to be, you can change it. We can do that using the function setwd():\nsetwd(\"/this/should/be/your/working-directory/path\")\nFor example, I will change mine to:\nsetwd(\"~/Library/CloudStorage/OneDrive-TheOhioStateUniversity/Desktop/OSU - Soybean Pathology & Nematology/OSU - SOY PATH AND NEMA/YEAR - SEMESTER/2025/SUMMER 2025/EXTENSION AND OUTREACH/03_carpentries-aug-2025 - AUG_18_2025\")\n\n\n\n\n\n\nNoteRStudio Projects\n\n\n\nIf you change your working dir in the R console, what is shown in the Files tab in the bottom-right does not automatically follow along. In that case, to show the files in your working dir in the Files tab, click the gear icon in that tab, and select Go To Working Directory.\nHowever, there is a better way of dealing with working directories, which is to avoid using setwd() altogether and to use RStudio Projects instead.\nTo learn more about RStudio Projects, see this section in the free book R for Data Science."
  },
  {
    "objectID": "2_data-structures.html#introduction",
    "href": "2_data-structures.html#introduction",
    "title": "R’s data structures and data types",
    "section": "1 Introduction",
    "text": "1 Introduction\n\n1.1 What we’ll cover\nIn this session, you will learn about some of the nuts and bolts of R, which will give you a solid foundation to start doing more exciting things in the next two sessions of this workshop: data wrangling and data visualization.\nSpecifically, we will cover R’s data structures and data types.\n\nData structures are the kinds of objects that R can store data in. Here, we’ll see the two most common ones: vectors and data frames.\nData types are how R distinguishes between different kinds of data like numbers versus character strings. Here, we’ll talk about the 4 main data types: character, integer, double, and logical.\n\nAn analogy: If this was about food rather than data, you can think of different data types as different food items, and various data structures as different types of containers to store food in.\n\n\n1.2 Setting up\nTo make it easier to keep track of what we do, we’ll write our code in a script:\n\nOpen a new R script: Click the + symbol in the top toolbar, then click R Script1.\nSave the script straight away as data-structures.R. You can save it anywhere you like, but ideally in a folder that is specifically for this workshop.\nIf you want section headers as comments in your script, like in the script I am showing you in the live session, then copy-and-paste the following into your script:\n\n\n\nSection headers for your script (Click to expand)\n\n\n# 2 - Vectors ------------------------------------------------------------------\n# 2.1 - Single-element vectors (and quoting)\n\n# 2.2 - Multi-element vectors\n\n# 2.3 - Vectorization\n\n# Challenge 1\n# - Make a vector `x` with the whole numbers 1 through 26.\n#   Then, subtract 0.5 from each element in `x` and save the result in vector `y`.\n#   Check your results by printing both vectors.\n\n# - Bonus: What do you think the result of the following operation will be?\n#   1:5 * 1:5\n#   We didn't cover this kind of scenario, but go ahead and test your intuition!\n#   After you've decided on your expectation,\n#   run the code and check if you were correct.\n\n# 2.4 - Exploring vectors\n\n# 2.5 - Extracting element from vectors\n\n# 3 - Data frames --------------------------------------------------------------\n\n# 4 - Data types ---------------------------------------------------------------\n# 4.1 - R's main data types\n\n# 4.3 - A vector can only contain one data type\n\n# Challenge 2\n# What type of vector (if any) do you think each of the following will produce?\n# Try it out and see if you were right.\n#   typeof(\"TRUE\")\n#   typeof(banana)\n#   typeof(c(2, 6, \"3\"))\n\n# 4.5 - Manual type conversion"
  },
  {
    "objectID": "2_data-structures.html#the-vector-data-structure",
    "href": "2_data-structures.html#the-vector-data-structure",
    "title": "R’s data structures and data types",
    "section": "2 The vector data structure",
    "text": "2 The vector data structure\nThe first data structure we will explore is the simplest: the vector. A vector in R is essentially a collection of one or more items. Moving forward, we’ll call such individual items “elements”.\n\n2.1 Single-element vectors (and quoting)\nVectors can consist of just a single element, so each of the two lines of code below creates a vector:\n\nvector1 &lt;- 8\nvector2 &lt;- \"panda\"\n\nIn the \"panda\" example, which is a character string (string for short):\n\n\"panda\" constitutes one element, not 5 (its number of letters).\nUnlike when dealing with numbers, we have to quote the string.2\n\nCharacter strings need to be quoted because they are otherwise interpreted as R objects – for example, because our vectors vector1 and vector2 are objects, we refer to them without quotes:\n\n# [Note that R will show auto-complete options after you type 3 characters]\nvector1\n\n[1] 8\n\nvector2\n\n[1] \"panda\"\n\n\nMeanwhile, the code below doesn’t work because there is no object called panda:\n\nvector_fail &lt;- panda\n\nError: object 'panda' not found\n\n\n\n\n2.2 Multi-element vectors\nA common way to make vectors with multiple elements is by using the c (combine) function:\n\nc(2, 6, 3)\n\n[1] 2 6 3\n\n\n\n\n\n\n\n\nUnlike in the first couple of vector examples, we didn’t save the above vector to an object: now the vector simply printed to the console – but it is created all the same.\n\n\n\nc() can also append elements to an existing vector:\n\n# First we create a vector:\nvector_to_append &lt;- c(\"cardinal\", \"chickadee\")\nvector_to_append\n\n[1] \"cardinal\"  \"chickadee\"\n\n# Then we append another element to it:\nc(vector_to_append, \"bald eagle\")\n\n[1] \"cardinal\"   \"chickadee\"  \"bald eagle\"\n\n\nTo create vectors with series of numbers, a couple of shortcuts are available. First, you can make series of whole numbers (integers) with the : operator:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nSecond, you can use a function like seq() and its arguments from (starting value), to (end value), and by (step size) for fine control over the sequence:\n\nstepwise_vec &lt;- seq(from = 6, to = 8, by = 0.2)\nstepwise_vec\n\n [1] 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0\n\n\n\n\n2.3 Vectorization\nConsider the output of this command:\n\nstepwise_vec * 2\n\n [1] 12.0 12.4 12.8 13.2 13.6 14.0 14.4 14.8 15.2 15.6 16.0\n\n\nAbove, every individual element in stepwise_vec was multiplied by 2. We call this behavior “vectorization” and this is a key feature of the R language. (Alternatively, you may have expected this code to repeat stepwise_vec twice, but this did not happen!)\n\n\n Challenge 1\nMake a vector x with the whole numbers 1 through 26. Then, subtract 0.5 from each element in x and save the result in vector y. Check your results by printing both vectors.\n\n\nClick for the solution\n\n\nx &lt;- 1:26\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n\ny &lt;- x - 0.5\ny\n\n [1]  0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5 14.5\n[16] 15.5 16.5 17.5 18.5 19.5 20.5 21.5 22.5 23.5 24.5 25.5\n\n\n\n\n\nBonus: What do you think the result of the following operation will be? We didn’t cover this kind of scenario, but go ahead and test your intuition! After you’ve decided on your expectation, run the code and check if you were correct.\n\n1:5 * 1:5\n\n\n\nClick for the solution\n\n\n1:5 * 1:5\n\n[1]  1  4  9 16 25\n\n\nBoth vectors are of length 5 which will lead to “element-wise matching”: the first element in the first vector will be multiplied with the first element in the second vector, the second element in the first vector will be multiplied with the second element in the second vector, and so on.\n\n\n\n\n2.4 Exploring vectors\nR has many functions that provide information about vectors and other types of objects, such as:\n\nGet the number of elements with length():\n\nlength(stepwise_vec)\n\n[1] 11\n\n\nSee the first and last few elements, respectively, with head() and tail():\n\n# Print the first 6 elements:\nhead(stepwise_vec)\n\n[1] 6.0 6.2 6.4 6.6 6.8 7.0\n\n# Print the last 6 elements:\ntail(stepwise_vec)\n\n[1] 7.0 7.2 7.4 7.6 7.8 8.0\n\n# Both head and tail have argument `n` to specify the number of elements:\ntail(stepwise_vec, n = 2)\n\n[1] 7.8 8.0\n\n\nGet arithmetic summaries like mean() for vectors with numbers:\n\n# mean() will compute the mean (average) across all elements\nmean(stepwise_vec)\n\n[1] 7\n\n\n\n\n\n2.5 Extracting elements from vectors\nExtracting element from objects like vectors is often called “indexing”. In R, we can do this using “bracket notation” with square brackets [ ] – for example:\n\nGet the second element with [2]3:\n\nstepwise_vec[2]\n\n[1] 6.2\n\n\nGet the second through the fifth elements with [2:5]:\n\nstepwise_vec[2:5]\n\n[1] 6.2 6.4 6.6 6.8\n\n\nGet the first and eight elements with [c(1, 8)]:\n\nstepwise_vec[c(1, 8)]\n\n[1] 6.0 7.4\n\n\n\n\n\n\n\n\n\nTo put this in a generalized way: we can extract elements from a vector by using another vector, whose values are the positional indices of the elements in the original vector."
  },
  {
    "objectID": "2_data-structures.html#the-data-frame-data-structure",
    "href": "2_data-structures.html#the-data-frame-data-structure",
    "title": "R’s data structures and data types",
    "section": "3 The data frame data structure",
    "text": "3 The data frame data structure\nOne of R’s most powerful features is its built-in ability to deal with tabular data – i.e., data with rows and columns like you are familiar with from Excel spreadsheets and so on. In R, tabular data is stored in a data structure called “data frame”.\nLet’s start by using the data.frame() function to make a data frame with information about 3 cats:\n\ncats &lt;- data.frame(\n  name = c(\"Luna\", \"Thomas\", \"Daisy\"),\n  coat = c(\"calico\", \"black\", \"tabby\"),\n  weight = c(2.1, 5.0, 3.2)\n  )\n\n\ncats\n\n    name   coat weight\n1   Luna calico    2.1\n2 Thomas  black    5.0\n3  Daisy  tabby    3.2\n\n\nAbove:\n\nWe created 3 vectors and pasted them side-by-side to create a data frame in which each vector constitutes a column.\nWe gave each vector a name (e.g., coat), and those names became the column names.\nThe resulting data frame has 3 rows (one for each cat) and 3 columns (each with a type of info about the cats, like coat color).\n\nIt is good practice to organize tabular data in the so-called “tidy” data format like above, where:\n\nEach column contains a different “variable” (e.g. coat color, weight)\nEach row contains a different “observation” (data on e.g. one cat/person/sample)\n\nThat’s all we’ll say about data frames for now, but in today’s remaining sessions we will explore this key R data structure more!"
  },
  {
    "objectID": "2_data-structures.html#data-types",
    "href": "2_data-structures.html#data-types",
    "title": "R’s data structures and data types",
    "section": "4 Data types",
    "text": "4 Data types\n\n4.1 R’s main data types\nR distinguishes between different kinds of data, such as character strings and numbers, using several pre-defined “data types”. R’s behavior in various operations depends heavily on the data type – for example, the below fails:\n\n\"valerion\" * 5\n\nError in \"valerion\" * 5: non-numeric argument to binary operator\n\n\nWe can ask what type of data something is in R using the typeof() function:\n\ntypeof(\"valerion\")\n\n[1] \"character\"\n\n\nR set the data type of \"valerion\" to character, i.e. a (character) string. The earlier command failed because R can’t perform mathematical functions (“binary operator”) on vectors of type character (“non-numeric argument”).\nThe character data type most commonly contains letters, but anything that is placed between quotes (\"...\") will be interpreted as this data type – even plain numbers:\n\ntypeof(\"5\")\n\n[1] \"character\"\n\n\nBesides character, three other common data types are:\n\ndouble / numeric – numbers that can have decimal points:\n\ntypeof(3.14)\n\n[1] \"double\"\n\n\ninteger – whole numbers only:\n\ntypeof(1:3)\n\n[1] \"integer\"\n\n\nlogical (either TRUE or FALSE – unquoted!):\n\ntypeof(TRUE)\n\n[1] \"logical\"\n\n\n\n\n\n4.2 A vector can only contain one data type\nA vector can only be composed of a single data type. As we saw above, R silently picks the “best-fitting” data type when you create a vector.\nThe same is true when you enter or read data into a data frame, where each column is a vector and can therefore only contain one data type.\nLet’s go back to our cats dataframe to find out what data types R assigned. We can quickly see each column’s data type and other information using the str() (structure) function:\n\nstr(cats)\n\n'data.frame':   3 obs. of  3 variables:\n $ name  : chr  \"Luna\" \"Thomas\" \"Daisy\"\n $ coat  : chr  \"calico\" \"black\" \"tabby\"\n $ weight: num  2.1 5 3.2\n\n\n\nThe name and coat columns are cxharacter, abbreviated chr.\nThe weight column is double/numeric, abbreviated num.\n\n\n Challenge 2\nIn each line below, what do you think the data type (if any) will be? Try it out and see if you were right.\n\ntypeof(\"TRUE\")\ntypeof(banana)\ntypeof(c(2, 6, \"3\"))\n\n\n\nClick for the solutions\n\n\n\n\"TRUE\" is character (and not logical) because of the quotes around it:\n\ntypeof(\"TRUE\")\n\n[1] \"character\"\n\n\n\n\n\nRecall the earlier example: this returns an error because the object banana does not exist. Any unquoted string (that is not a special keyword like TRUE and FALSE) is interpreted as a reference to an object in R.\n\ntypeof(banana)\n\nError: object 'banana' not found\n\n\n\n\n\nThis produces a character vector, and we’ll talk about why in the next section:\n\ntypeof(c(2, 6, \"3\"))\n\n[1] \"character\"\n\n\n\n\n\n\n\n4.3 Automatic Type Coercion\nR’s behavior of returning a character vector for c(2, 6, \"3\") in the challenge above is called type coercion.\nWhen R encounters a mix of data types (here, numbers and characters) to be combined into a single vector, it forces them all to be the same type. It “must” do this because a vector can consist of only a single data type.\nType coercion can be the source of many surprises, and is one reason you need to be aware of the basic R data types and how R’s behaviour around them.\n\n\n4.4 Manual Type Conversion\nLuckily, you are not just at the mercy of whatever R decides to do automatically, but can convert vectors using the as. group of functions:\n\n\n\n\n\n\nTipTry to use RStudio’s auto-complete functionality here: type “as.” and then press the Tab key.\n\n\n\n\n\n\n\nas.integer(c(\"0\", \"2\"))\n\n[1] 0 2\n\nas.character(c(0, 2))\n\n[1] \"0\" \"2\"\n\n\nAs you may have guessed, though, not all type conversions are possible — for example:\n\nas.double(\"kiwi\")\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\n(NA is R’s way of denoting missing data – see this bonus section for more.)\nThat’s it! In the next session, we’ll learn to manipulate and summarize data frames using a real dataset with periodic countrywise statistics such as population size."
  },
  {
    "objectID": "2_data-structures.html#bonus-material-for-self-study",
    "href": "2_data-structures.html#bonus-material-for-self-study",
    "title": "R’s data structures and data types",
    "section": "5 Bonus material for self-study",
    "text": "5 Bonus material for self-study\n\n5.1 Changing vector elements using indexing\nAbove, we saw how you can extract elements of a vector using indexing. To change elements in a vector, simply use the bracket on the other side of the arrow – for example:\n\nChange the first element to 30:\n\nstepwise_vec[1] &lt;- 30\nstepwise_vec\n\n [1] 30.0  6.2  6.4  6.6  6.8  7.0  7.2  7.4  7.6  7.8  8.0\n\n\nChange the last element to 0:\n\nstepwise_vec[length(stepwise_vec)] &lt;- 0\nstepwise_vec\n\n [1] 30.0  6.2  6.4  6.6  6.8  7.0  7.2  7.4  7.6  7.8  0.0\n\n\nChange the second element to the mean value of the vector:\n\nstepwise_vec[2] &lt;- mean(stepwise_vec)\nstepwise_vec\n\n [1] 30.000000  8.454545  6.400000  6.600000  6.800000  7.000000  7.200000\n [8]  7.400000  7.600000  7.800000  0.000000\n\n\n\n\n\n5.2 Extracting columns from a data frame\nYou can extract individual columns from a data frame using the $ operator:\n\ncats$weight\n\n[1] 2.1 5.0 3.2\n\ncats$coat\n\n[1] \"calico\" \"black\"  \"tabby\" \n\n\nThis kind of operation will return a vector – and can be indexed as well:\n\ncats$weight[2]\n\n[1] 5\n\n\n\n\n5.3 More on the logical data type\nAdd a column to your cats data frame that indicates whether each cat does or does not like string:\n\ncats$likes_string &lt;- c(1, 0, 1)\ncats\n\n    name   coat weight likes_string\n1   Luna calico    2.1            1\n2 Thomas  black    5.0            0\n3  Daisy  tabby    3.2            1\n\n\nSo, likes_string is numeric, but the 1s and 0s actually represent TRUE and FALSE.\nYou could instead use the logical data type here, by converting this column with the as.logical() function. That will turn 0’s into FALSE and everything else, including 1, to TRUE:\n\nas.logical(cats$likes_string)\n\n[1]  TRUE FALSE  TRUE\n\n\nTo actually modify this column in the dataframe itself:\n\ncats$likes_string &lt;- as.logical(cats$likes_string)\ncats\n\n    name   coat weight likes_string\n1   Luna calico    2.1         TRUE\n2 Thomas  black    5.0        FALSE\n3  Daisy  tabby    3.2         TRUE\n\n\nYou might think that 1/0 could be a handier coding than TRUE/FALSE because that enables easy counting of the number of times something is true or false. But consider the following R behavior:\n\nTRUE + TRUE\n\n[1] 2\n\n\nSo, logicals can be used as if they were numbers, where FALSE represents 0 and TRUE represents 1.\n\n\n5.4 Missing values (NA)\nR has a concept of missing data, which is important in statistical computing, as not all information/measurements are always available for each sample.\nIn R, missing values are coded as NA (like TRUE/FALSE, this is not a character string so it is not quoted):\n\n# This vector will contain one missing value\nvector_NA &lt;- c(1, 3, NA, 7)\nvector_NA\n\n[1]  1  3 NA  7\n\n\nNotably, many functions operating on vectors will return NA if any element in the vector is NA:\n\nsum(vector_NA)\n\n[1] NA\n\n\nYou can get around this is by setting na.rm = TRUE in such functions, for example:\n\nsum(vector_NA, na.rm = TRUE)\n\n[1] 11\n\n\n\n\n5.5 Factors\nCategorical data, like treatments in an experiment, can be stored as “factors” in R. Factors are useful for statistical analyses and for plotting, e.g. because they allow you to specify a custom order.\n\ndiet_vec &lt;- c(\"high\", \"medium\", \"low\", \"low\", \"medium\")\ndiet_vec\n\n[1] \"high\"   \"medium\" \"low\"    \"low\"    \"medium\"\n\nfactor(diet_vec)\n\n[1] high   medium low    low    medium\nLevels: high low medium\n\n\nIn the example above, we turned a character vector into a factor. Its “levels” (low, medium, high) are sorted alphabetically by default, but we can manually specify an order that makes more sense:\n\ndiet_fct &lt;- factor(diet_vec, levels = c(\"low\", \"medium\", \"high\"))\ndiet_fct\n\n[1] high   medium low    low    medium\nLevels: low medium high\n\n\nThis ordering would be automatically respected in plots and statistical analyses.\n\n\n\n\n\n\nWarningOddly, factors are technically not a data type (Click to expand)\n\n\n\n\n\nFor most intents and purposes, it makes sense to think of factors as another data type, even though technically, they are a kind of data structure build on the integer data type:\n\ntypeof(diet_fct)\n\n[1] \"integer\"\n\n\n\n\n\n\n\n5.6 Learn more\nTo learn more about data types and data structures, see this episode from a separate Carpentries lesson.\n\n\n Bonus Challenge\nAn important part of every data analysis is cleaning input data. Here, you will clean a cat data set that has an added observation with a problematic data entry.\nStart by creating the new data frame:\n\ncats_v2 &lt;- data.frame(\n  name = c(\"Luna\", \"Thomas\", \"Daisy\", \"Oliver\"),\n  coat = c(\"calico\", \"black\", \"tabby\", \"tabby\"),\n  weight = c(2.1, 5.0, 3.2, \"2.3 or 2.4\")\n)\n\nThen move on to the tasks below, filling in the blanks (_____) and running the code:\n\n# 1. Explore the data frame,\n#    including with an overview that shows the columns' data types:\ncats_v2\n_____(cats_v2)\n\n# 2. The \"weight\" column has the incorrect data type _____.\n#    The correct data type is: _____.\n\n# 3. Correct the 4th weight with the mean of the two given values,\n#    then print the data frame to see the effect:\ncats_v2$weight[4] &lt;- 2.35\ncats_v2\n\n# 4. Convert the weight column to the right data type:\ncats_v2$weight &lt;- _____(cats_v2$weight)\n\n# 5. Calculate the mean weight of the cats:\n_____\n\n\n\nClick for the solution\n\n\n# 1. Explore the data frame,\n#    including with an overview that shows the columns' data types:\ncats_v2\n\n    name   coat     weight\n1   Luna calico        2.1\n2 Thomas  black          5\n3  Daisy  tabby        3.2\n4 Oliver  tabby 2.3 or 2.4\n\nstr(cats_v2)\n\n'data.frame':   4 obs. of  3 variables:\n $ name  : chr  \"Luna\" \"Thomas\" \"Daisy\" \"Oliver\"\n $ coat  : chr  \"calico\" \"black\" \"tabby\" \"tabby\"\n $ weight: chr  \"2.1\" \"5\" \"3.2\" \"2.3 or 2.4\"\n\n# 2. The \"weight\" column has the incorrect data type CHARACTER.\n#    The correct data type is: DOUBLE/NUMERIC.\n\n# 3. Correct the 4th weight data point with the mean of the two given values,\n#    then print the data frame to see the effect:\ncats_v2$weight[4] &lt;- 2.35\ncats_v2\n\n    name   coat weight\n1   Luna calico    2.1\n2 Thomas  black      5\n3  Daisy  tabby    3.2\n4 Oliver  tabby   2.35\n\n# 4. Convert the weight column to the right data type:\ncats_v2$weight &lt;- as.double(cats_v2$weight)\n\n# 5. Calculate the mean weight of the cats:\nmean(cats_v2$weight)\n\n[1] 3.1625"
  },
  {
    "objectID": "2_data-structures.html#footnotes",
    "href": "2_data-structures.html#footnotes",
    "title": "R’s data structures and data types",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n Or Click File =&gt; New file =&gt; R Script.↩︎\n Either double quotes (\"...\") or single quotes ('...') work, but the former are most commonly used by convention.↩︎\n R uses 1-based indexing, which means it starts counting at 1 like humans do. Index 2 therefore simply corresponds to the second element.  Python and several other languages use 0-based indexing, which starts counting at 0 such that the second element corresponds to index 1.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Workshop on R for Reproducibility",
    "section": "",
    "text": "Register here if you haven’t done so already.\n\nSchedule\n\n\n\nTime\nInstructor\nTopic & link\n\n\n\n\nBefore starting\n\nInstall and set up R and RStudio\n\n\n9:00 - 9:20 am\nHoracio\nPre-workshop survey (if only attending today), intro, logistics\n\n\n9:20 - 10:15 am\nHoracio\n1: Introduction to R and RStudio\n\n\n10:15 - 10:30 am\n\nCoffee break  \n\n\n10:30 - 11:30 am\nJelmer\n2: R’s data structures and data types\n\n\n11:30 am - 12:15 pm\n\nLunch break  \n\n\n12:15 - 1:15 pm\nJelmer\n3: Data wrangling with dplyr\n\n\n1:15 - 1:30 pm\n\nCoffee break  \n\n\n1:30 - 2:50 pm\nJessica\n4: Data visualization with ggplot2\n\n\n2:50 - 3:00 pm\n\nPost-workshop survey\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "1 Ohio State R for Reproducible Research Carpentries Workshop February 13, 2026",
    "section": "",
    "text": "1 Ohio State R for Reproducible Research Carpentries Workshop February 13, 2026\nThis is source repo for the website for the hands-on “R for Reproducibility” workshop taught at Ohio State University on February 13, 2026.\nThis workshop is taught by the organizers of Ohio State’s Code Club, Jelmer Poelstra, Horacio Lopez-Nicora, and Jessica Cooperstone.\nYou can find the website with course materials at https://osu-codeclub.github.io/carpentries-feb-2026/ and some information about the sister workshop on Version Control with Git here.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this website",
    "section": "",
    "text": "This is the website for the hands-on “R for Reproducibility” workshop taught at Ohio State University on August 18th, 2025.\n\nPractical information about the workshop\nR is a programming language that is especially powerful for data exploration, visualization, and statistical analysis. During this workshop, participants will learn the basics of R and RStudio, and how to use R for reproducible data manipulation and visualization.\nIf you are affiliated with Ohio State University in any capacity, you can attend this workshop for free by registering here. You can find some more information about the workshop here.\nThere are no prerequisites: this workshop is suitable for complete beginners in R and in coding in general. This workshop is taught online via Zoom.\n\n\nInstructors and organizers\nThis workshop is taught by the organizers of OSU Code Club:\n\nHoracio Lopez-Nicora  – Assistant Professor in the department of Plant Pathology\nJelmer Poelstra  – Bioinformatics & Microscopy Lead at the CFAES Molecular and Cellular Imaging Center (MCIC)\nJessica Cooperstone  – Associate Professor in the departments of Horticulture & Crop Science, and Food Science & Technology\n\nThe following helpers will be assisting participants:\n\nHannah Toth\nMenuka Bhandari\nKelsey Badger\nMatthew Thompson\nElizabeth Campolongo\nNet Zhang\nJay\n\nThis workshop is organized by Kelsey Badger at the OSU Research Commons, and Matthew Thompson and Elizabeth Campolongo at the OSU Imageomics Institute.\n\n\nThe Carpentries\nThis is a Carpentries workshop. The Carpentries project comprises the Software Carpentry, Data Carpentry, and Library Carpentry communities of Instructors, Trainers, Maintainers, helpers, and supporters who share a mission to teach foundational computational and data science skills to researchers.\nThe material on this website has been adapted from the R for Reproducible Scientific Analysis Software Carpentry lesson.\nA sister workshop is being held on February 9th on version control with Git and GitHub.\n\n\n\n\n Back to top"
  }
]